# 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 (오름차순), 혹은 그 반대의 순서대로 (내림차순) 재배열하는 것
- 키 : 자료를 정렬하는 기준이 되는 특정 값
- 대표적인 정렬 방식의 종류
    - **버블 정렬 (Bubble Sort)**
    - **카운팅 정렬 (Counting Sort)**
    - **선택 정렬 (Selection Sort)**
    - 퀵 정렬 (Quick Sort)
    - 삽입 정렬 (Insertion Sort)
    - 병합 정렬 (Merge Sort)

<br>

## 1. 버블 정렬 `Bubble Sort`

### 1) 정의
-  인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
### 2) 정렬 과정
- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬이라고 한다.
- 기준인덱스를 바꿔가는 방식, <br> 0 부터 늘려가는 방식

### 3) 시간 복잡도
- `O(n^2)`

## 2. 카운팅 정렬 `Counting Sort`

### 1) 정의
-  집합에 각 항목이 몇 개씩 있는지 세는 작업을 하며, 선형 공간에 정렬하는 효율적인 알고리즘

### 2) 제한사항
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 인덱스되는 카운트들의 배열을 사용하기 때문
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

### 3) 시간 복잡도
-  `O(n+k)`
    - n은 리스트 길이
    - k는 정수의 최댓값

### 4) 정렬과정
- 1단계 : Data에서 각 항목들의 발생횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장한다.
- 2단계 : 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
- 3단계 : counts[1]을 감소시키고 Temp에 1을 삽입한다.

- 버블 정렬에 비해 효율적이지만, 코드는 복잡함.
    - N만큼 count 길이를 만들고 시작하니까, 메모리 낭비임.

## 3. 선택 정렬 `Selection Sort`
### 1) 정의
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

### 2) 정렬 과정
- 주어진 리스트 중 최소값을 찾는다.
- 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
- 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

### 3) 시간 복잡도
- `O(n^2)`

### 4) 구현
```python
def SelectionSort(a, N):
	for i in range(N-1):
		min_idx = i
		for j in range(i+1, N):
			if a[min_idx] > a[j]:
				min_idx = j
				
		a[i], a[min_idx] = a[min_idx], a[i]
```


## 참고
### 1) 셀렉션 알고리즘
- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 선택 과정
    - 정렬 알고리즘을 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기